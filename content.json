{"meta":{"title":"EsNaSc","subtitle":"","description":"personal blog of learning","author":"FeOAr","url":"https://github.com/FeOAr/FeOAr.github.io.git","root":"/"},"pages":[{"title":"标签","date":"2020-10-08T04:29:59.000Z","updated":"2020-10-08T04:32:13.809Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"STM32工程建立","slug":"STM32工程建立及流水灯软件部分实现","date":"2021-04-19T16:00:00.000Z","updated":"2021-04-20T08:02:54.225Z","comments":true,"path":"2021/04/20/STM32工程建立及流水灯软件部分实现/","link":"","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/2021/04/20/STM32%E5%B7%A5%E7%A8%8B%E5%BB%BA%E7%AB%8B%E5%8F%8A%E6%B5%81%E6%B0%B4%E7%81%AF%E8%BD%AF%E4%BB%B6%E9%83%A8%E5%88%86%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"STM32工程建立 本工程建立在已有工程基础上 新建新工程文件夹 复制基础例程 添加驱动文件进工程库 4. 导入外设和内核支撑 5. 在kile中新建项目并创建工程文件 6. 选择芯片型号 7. 配置文件环境 8. 配置库路径 9. 宏定义设置 10. 屏蔽项目用不到的头文件调用","categories":[],"tags":[{"name":"课后作业","slug":"课后作业","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"}]},{"title":"流水灯实现","slug":"流水灯实现","date":"2021-04-19T16:00:00.000Z","updated":"2021-04-20T08:02:57.651Z","comments":true,"path":"2021/04/20/流水灯实现/","link":"","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/2021/04/20/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"流水灯实现 查看原理图选择需要的LED和按键 在程序中初始化以及定义引脚功能 1234567891011121314151617void init()&#123; GPIO_InitTypeDef zhr_18060103118; //1.GPIO结构体定义 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF|RCC_APB2Periph_GPIOA, ENABLE); //时钟,GPIO的F口使能 zhr_18060103118.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9; zhr_18060103118.GPIO_Speed = GPIO_Speed_50MHz; zhr_18060103118.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出 GPIO_Init(GPIOF, &amp;zhr_18060103118); zhr_18060103118.GPIO_Pin = GPIO_Pin_0; zhr_18060103118.GPIO_Speed = GPIO_Speed_50MHz; zhr_18060103118.GPIO_Mode = GPIO_Mode_IPD; //下拉输入 GPIO_Init(GPIOA, &amp;zhr_18060103118);&#125; 移位实现流水灯，引入按键添加效果 1234567891011121314151617181920int main(void)&#123; int i; init(); while (1) &#123; for(i=6;i&lt;10;i++)&#123; if(0x00000000==(GPIOA-&gt;IDR&amp;0x00000001)) &#123; GPIOF-&gt;ODR &amp;= 0; delay(10000); &#125; GPIOF-&gt;ODR |= 0x00000001 &lt;&lt; i; //Fi置1 delay(10000); //延时函数较简单，此处没有展现 GPIOF-&gt;ODR &amp;= ~~0x00000001 &lt;&lt; i; //Fi清0 delay(10000); &#125; &#125; &#125;","categories":[],"tags":[{"name":"课后作业","slug":"课后作业","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"}]},{"title":"社区水电气管理系统","slug":"社区水电气管理","date":"2020-12-29T16:00:00.000Z","updated":"2020-12-30T15:39:24.101Z","comments":true,"path":"2020/12/30/社区水电气管理/","link":"","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/2020/12/30/%E7%A4%BE%E5%8C%BA%E6%B0%B4%E7%94%B5%E6%B0%94%E7%AE%A1%E7%90%86/","excerpt":"","text":"社区水电气管理系统 摘要 本来是打算工作的，虽然对嵌入式行业充满兴趣但是还是准备学个Java去早早当码农。于是匆匆学了两周Java，看的网课是阿b上的狂神说Java。学了个SE又打算考研了，，，，但是两周的努力不能付诸东流啊，于是才有了这个微型项目。题目我C++课设时选择的，于是顺便拿来再写一个Java版本。 代码与思路比较简单，算是两周学习的一个小成果吧~ 项目github链接 源代码Main.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263package Base.CommunityManagementSystem;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Scanner;/** * @author FeOAr,feoar@outlook.com * @version 1.0 * * &lt;p&gt;2020/10/28进度：增删改查基本实现,需要细化。&lt;/p&gt; * * * @version 1.1 * &lt;p&gt;2020/10/28进度：在main类中直接将输入的信息组织成sql代码，字符串传入@JavaMySql中，减少重载。&lt;/p&gt; * * @version 1.2 * &lt;p&gt;2020/11/2进度：目前还差一个计算的主要功能，增删改查已经基本实现，目前在做该方向的最后一点问题： * 即查询函数&#123;@link Base.CommunityManagementSystem.JavaMySql#Query(String)&#125;的输出显示格式需要变化问题。 * - 注意水电气费用位浮点型&lt;/p&gt; * @version 1.3 * &lt;p&gt;2020/11/3进度：基本需求已经实现，接下来需要润色： * - 主要是大量由学生信息向社区信息变化的变量名,字段没有修改 * - 各功能执行完毕后的结束或跳转问题，参考155行 * - 费用的浮点型在数据库表中仍未修改&lt;/p&gt; * * */public class Main &#123; public static final int STUDENTNUMLENGTH = 4; //编号长度 public static float WATERPRICE = 1; //水电气单价 public static float NATURALGASPRICE = 2; public static float ELECTRICITYPRICE = 3; public static void main(String[] args) &#123; Main main = new Main(); main.mainMenu(); // 显示主菜单 main.mainAction(main.mainMenuChoice()); &#125; public void mainMenu()&#123; System.out.println(&quot;\\n\\n\\t社区水电气管理系统\\n\\n&quot;); System.out.println(&quot;\\t1.缴费&quot;); System.out.println(&quot;\\t2.查询用户用量&quot;); System.out.println(&quot;\\t3.添加用户&quot;); System.out.println(&quot;\\t4.修改用户&quot;); System.out.println(&quot;\\t5.删除用户&quot;); System.out.println(&quot;\\t6.显示用户信息&quot;); System.out.println(&quot;\\t7.显示水电气统计数据&quot;); System.out.println(&quot;\\t8.新增月水电气数据&quot;); System.out.println(&quot;\\t9.增改月水电气数据&quot;); System.out.println(&quot;\\t10.设置当月水电气价格&quot;); System.out.println(&quot;\\t11.退出系统\\n&quot;); &#125; public int mainMenuChoice()&#123; System.out.print(&quot;请输入序号作为选择：&quot;); Scanner Input = new Scanner(System.in); return Input.nextInt(); &#125; public void mainAction(int Choice) &#123; switch (Choice) &#123; case 1 -&gt; pay(); case 2 -&gt; queryMenu(); case 3 -&gt; addUser(); case 4 -&gt; Update.UpdateInfo(); case 5 -&gt; deleteMenu(); case 6 -&gt; &#123; System.out.println(&quot;请输入需要查询的用户的编号或身份证号。如需查看所有，请输入a&quot;); Scanner Input = new Scanner(System.in); String id = Input.next(); search(id,6); &#125; case 7 -&gt; JavaMySql.calculate(); case 8 -&gt; JavaMySql.crateNewTable(); case 9 -&gt; insertMonthInform(); case 10 -&gt; Price(); case 11 -&gt; exit(); default -&gt; System.out.println(&quot;ERROR 请重新选择&quot;); &#125; &#125; public void pay()&#123; String sqlCmd; float waterCost = -1; float naturalGasCost = -1; float electricityCost = -1; boolean payFlag; boolean payStatus = false; System.out.println(&quot;请输入需要缴费的用户的编号或身份证号：&quot;); Scanner Input = new Scanner(System.in); String id = Input.next(); System.out.println(&quot;请输入缴费月份：&quot;); int month = Input.nextInt(); String type; if(id.length() &lt;= STUDENTNUMLENGTH)&#123; type = &quot;userNo&quot;; &#125;else&#123; type = &quot;identityId&quot;; &#125; if(WATERPRICE &gt; 0 &amp;&amp; ELECTRICITYPRICE &gt; 0 &amp;&amp; NATURALGASPRICE &gt; 0)&#123; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; conn = JdbcUtils.getConnection(); //获取数据库连接 st = conn.createStatement(); //获得SQl执行对象 rs = st.executeQuery(&quot;SELECT `water`,`naturalGas`,`electricity`,`expenseStatus`\\n&quot; + &quot;FROM info&quot;+month+&quot;\\n&quot; + &quot;WHERE userNo = &#x27;&quot;+id+&quot;&#x27;; &quot;); //查询完返回一个结果集 while(rs.next())&#123; System.out.print(&quot;当月用水量：&quot;+rs.getObject(&quot;water&quot;)); System.out.print(&quot;\\t当月用气量：&quot;+rs.getObject(&quot;naturalGas&quot;)); System.out.println(&quot;\\t当月用电量：&quot;+rs.getObject(&quot;electricity&quot;)); waterCost = WATERPRICE * (int) rs.getObject(&quot;water&quot;); naturalGasCost = NATURALGASPRICE * (int) rs.getObject(&quot;naturalGas&quot;); electricityCost = ELECTRICITYPRICE * (int) rs.getObject(&quot;electricity&quot;); payStatus = (Boolean) rs.getObject(&quot;expenseStatus&quot;); &#125; if(payStatus) System.out.println(&quot;已经交过费了&quot;); //此处应该实现交过费后结束或回主页而不是继续执行 System.out.println(&quot;当月水单价：&quot;+WATERPRICE+&quot;\\t当月气单价：&quot;+NATURALGASPRICE+&quot;\\t当月电单价：&quot;+ELECTRICITYPRICE); System.out.println(&quot;应交水费：&quot;+waterCost+&quot;元\\n&quot;+ &quot;应交燃气费：&quot;+naturalGasCost+&quot;元\\n&quot;+ &quot;应交电费：&quot;+electricityCost+&quot;元\\n&quot; + &quot;是否缴费：（Y/N）&quot;); payFlag = Input.next().equals(&quot;y&quot;) || Input.next().equals(&quot;Y&quot;); sqlCmd = &quot;UPDATE `info&quot;+month+&quot;` SET waterCharge = &quot;+waterCost+&quot;, \\n&quot; + &quot;naturalGasCharge = &quot;+naturalGasCost+&quot;,\\n&quot; + &quot;electricityCharge = &quot;+electricityCost+&quot;,\\n&quot; + &quot;expenseStatus = &quot;+payFlag+&quot;\\n&quot; + &quot;WHERE userNo = &quot;+id+&quot;; &quot;; if (payFlag &amp;&amp; st.executeUpdate(sqlCmd) &gt; 0) &#123; System.out.println(&quot;付费成功！&quot;); &#125;else System.out.println(&quot;ERROR&quot;); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JdbcUtils.release(conn, st, rs); &#125; &#125; sqlCmd = &quot;SELECT * FROM info&quot;+month+&quot; WHERE `&quot;+type+&quot;` = &#x27;&quot; + id+&quot;&#x27;&quot;; JavaMySql.QueryUseInfo(sqlCmd); System.out.println(&quot;返回主界面还是退出(M/E):&quot;); if(Input.next().equals(&quot;m&quot;) || Input.next().equals(&quot;M&quot;)) &#123; mainMenu(); //不执行任何函数，退出 mainAction(mainMenuChoice()); &#125; &#125; public void queryMenu()&#123; System.out.println(&quot;请输入需要查询的用户的编号：&quot;); Scanner Input = new Scanner(System.in); String id = Input.next(); search(id,2); //search函数将输入的字符串加工成可识别的编号或身份证号 &#125; public void addUser()&#123; System.out.println(&quot;请输入需要添加的所有信息&quot;); //&#x27;1008&#x27;,&#x27;123456&#x27;,&#x27;zhr&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;13379059095&#x27;,&#x27;陕西西安&#x27;,&#x27;1999-11-21&#x27;,&#x27;feoar@outlook.com&#x27;,&#x27;123100198654011234&#x27; Scanner Input = new Scanner(System.in); String sqlCmd = &quot;INSERT INTO `school`.`student` &quot; + &quot;(studentNo,`loginPwd`,`studentName`,`sex`,`gradeId`,`phone`,`address`,`bornDate`,`email`,`identityId`)\\n&quot; + &quot;VALUES (&quot; + Input.nextLine() + &quot;)&quot;; JavaMySql.Insert(sqlCmd); &#125; public void deleteMenu()&#123; String sqlCmd; System.out.println(&quot;请输入需要删除的学生的学号或身份证号：&quot;); Scanner Input = new Scanner(System.in); String id = Input.next(); String type; if(id.length() &lt;= STUDENTNUMLENGTH)&#123; type = &quot;studentNo&quot;; &#125;else&#123; type = &quot;identityId&quot;; &#125; sqlCmd = &quot;DELETE FROM student WHERE `&quot;+type+&quot;` = &#x27;&quot; + id+&quot;&#x27;&quot;; JavaMySql.Delete(sqlCmd); &#125; public static void search(String idOtherFunction,int flag)&#123; String sqlCmd = null; String type; Scanner Input = new Scanner(System.in); if(idOtherFunction.length() &lt;= STUDENTNUMLENGTH)&#123; //两种输入方式 type = &quot;studentNo&quot;; &#125;else&#123; type = &quot;identityId&quot;; &#125; if(idOtherFunction.equals(&quot;a&quot;))&#123; sqlCmd = &quot;&quot;&quot; SELECT *\\s FROM student s; &quot;&quot;&quot;; &#125;else if(flag == 6)&#123; sqlCmd = &quot;SELECT * FROM student WHERE `&quot;+type+&quot;`= &#x27;&quot;+idOtherFunction+&quot;&#x27;&quot;; &#125;else if(flag == 2)&#123; System.out.println(&quot;输入查询的月份：&quot;); int month = Input.nextInt(); System.out.println(idOtherFunction); if(idOtherFunction.length()==4) sqlCmd = &quot;SELECT * FROM Info&quot;+month+&quot; WHERE `userNo`= &#x27;&quot;+idOtherFunction+&quot;&#x27;&quot;; else System.out.println(&quot;请使用用户的编号查询，暂不支持身份证号查询&quot;); &#125; JavaMySql.Query(sqlCmd); &#125; public void insertMonthInform()&#123; Scanner Input = new Scanner(System.in); System.out.println(&quot;请输入需要添加数据的月份:&quot;); int monthTab = Input.nextInt(); if(monthTab &gt;= 1 &amp;&amp; monthTab &lt;= 12)&#123; System.out.print(&quot;请输入需要添加的用户编号，水电气数据:\\n&quot;); Input.nextLine(); String value = Input.nextLine(); //&#x27;1001&#x27;, &#x27;25&#x27;, &#x27;265&#x27;, &#x27;15&#x27; String sqlCmd = &quot;INSERT INTO `school`.`month&quot;+monthTab+&quot;` &quot; + &quot;(`userNo`,`water`,`naturalGas`,`electricity`)\\n&quot; + &quot;VALUES (&quot; + value + &quot;);&quot;; JavaMySql.Insert(sqlCmd); &#125;else System.out.println(&quot;非法输入&quot;); &#125; public void Price()&#123; Scanner Input = new Scanner(System.in); System.out.print(&quot;请输入当月水单价：&quot;); WATERPRICE =Input.nextFloat(); System.out.print(&quot;请输入当月电单价：&quot;); ELECTRICITYPRICE =Input.nextFloat(); System.out.print(&quot;请输入当月气单价：&quot;); NATURALGASPRICE =Input.nextFloat(); &#125; public void exit()&#123; System.out.println(&quot;(9)&quot;); &#125;&#125; Update.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package Base.CommunityManagementSystem;import java.util.Scanner;public class Update &#123; public static void UpdateInfo()&#123; menu(); &#125; public static void menu()&#123; Scanner Input = new Scanner(System.in); System.out.print(&quot;请输入要更新信息的用户学号或身份证号：&quot;); String id = Input.next(); Main.search(id,0); //此处应该输出一个查询结果，表示查到此人 boolean FLAG; String sqlCmd; FLAG = id.length() &lt;= 4; //此处需要测试 String poolString; int poolNumber; String type; if(FLAG)&#123; type = &quot;studentNo&quot;; &#125;else&#123; type = &quot;identityId&quot;; &#125; System.out.println(&quot;选择要更新的项目：&quot;); System.out.println(&quot;&quot;&quot; \\t1.修改学号 \\t2.修改登陆密码 \\t3.修改姓名 \\t4.修改性别 \\t5.修改年级 \\t6.修改电话 \\t7.修改户籍地址 \\t8.修改出生时间 \\t9.修改邮箱 \\t10.修改身份证号&quot;&quot;&quot;); System.out.print(&quot;请选择：&quot;); switch (Input.nextInt()) &#123; case 1 -&gt; &#123; System.out.print(&quot;请输入新学号：&quot;); poolNumber = Input.nextInt(); sqlCmd = &quot;UPDATE student SET `studentNo` =&quot;+poolNumber+&quot; WHERE &quot;+type+&quot; = &#x27;&quot;+id+&quot;&#x27;&quot;; JavaMySql.Update(sqlCmd); &#125; case 2 -&gt; &#123; System.out.print(&quot;请输入新密码：&quot;);//此处后期需要加入旧密码校对 poolNumber = Input.nextInt(); sqlCmd = &quot;UPDATE student SET `login` =&quot;+poolNumber+&quot; WHERE &quot;+type+&quot; = &#x27;&quot;+id+&quot;&#x27;&quot;; JavaMySql.Update(sqlCmd); &#125; case 3 -&gt; &#123; System.out.println(&quot;请输入新姓名：&quot;); poolString = Input.next(); sqlCmd = &quot;UPDATE student SET `studentName` =&#x27;&quot;+poolString+&quot;&#x27; WHERE &quot;+type+&quot; = &#x27;&quot;+id+&quot;&#x27;&quot;; System.out.println(sqlCmd); JavaMySql.Update(sqlCmd); &#125; case 4 -&gt; &#123; System.out.print(&quot;请输入新性别：&quot;); poolString = Input.next(); sqlCmd = &quot;UPDATE student SET `sex` =&quot;+poolString+&quot; WHERE &quot;+type+&quot; = &#x27;&quot;+id+&quot;&#x27;&quot;; JavaMySql.Update(sqlCmd); &#125; case 5 -&gt; &#123; System.out.print(&quot;请输入新年级：&quot;); poolNumber = Input.nextInt(); sqlCmd = &quot;UPDATE student SET `gradeId` =&quot;+poolNumber+&quot; WHERE &quot;+type+&quot; = &#x27;&quot;+id+&quot;&#x27;&quot;; JavaMySql.Update(sqlCmd); &#125; case 6 -&gt; &#123; System.out.print(&quot;请输入新电话：&quot;); poolString = Input.next(); sqlCmd = &quot;UPDATE student SET `phoneNum` =&quot;+poolString+&quot; WHERE &quot;+type+&quot; = &#x27;&quot;+id+&quot;&#x27;&quot;; JavaMySql.Update(sqlCmd); &#125; case 7 -&gt; &#123; System.out.print(&quot;请输入新户籍地址：&quot;); poolString = Input.next(); sqlCmd = &quot;UPDATE student SET `address` =&quot;+poolString+&quot; WHERE &quot;+type+&quot; = &#x27;&quot;+id+&quot;&#x27;&quot;; JavaMySql.Update(sqlCmd); &#125; case 8 -&gt; &#123; System.out.println(&quot;请输入新出生时间：(格式为 2020-10-01或20201001)&quot;); poolNumber = Input.nextInt(); sqlCmd = &quot;UPDATE student SET `bornDate` =&quot;+poolNumber+&quot; WHERE &quot;+type+&quot; = &#x27;&quot;+id+&quot;&#x27;&quot;; JavaMySql.Update(sqlCmd); &#125; case 9 -&gt; &#123; System.out.print(&quot;请输入新邮箱：&quot;); poolString = Input.next(); sqlCmd = &quot;UPDATE student SET `email` =&quot;+poolString+&quot; WHERE &quot;+type+&quot; = &#x27;&quot;+id+&quot;&#x27;&quot;; JavaMySql.Update(sqlCmd); &#125; case 10 -&gt; &#123; System.out.print(&quot;请输入新身份证号：&quot;); poolString = Input.next(); sqlCmd = &quot;UPDATE student SET `identityId` =&quot;+poolString+&quot; WHERE &quot;+type+&quot; = &#x27;&quot;+id+&quot;&#x27;&quot;; JavaMySql.Update(sqlCmd); &#125; default -&gt; System.out.println(&quot;ERROR 请重新选择&quot;); &#125; &#125;&#125; JdbcUtils.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package Base.CommunityManagementSystem;//import java.io.IOException;import java.io.InputStream;import java.sql.*;import java.util.Properties; public class JdbcUtils &#123; private static String driver =null; private static String url =null; private static String username =null; private static String password =null; static &#123; try &#123; InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;); Properties properties = new Properties(); properties.load(in); driver = properties.getProperty(&quot;driver&quot;); url = properties.getProperty(&quot;url&quot;); username = properties.getProperty(&quot;username&quot;); password = properties.getProperty(&quot;password&quot;); //1.驱动只加载一次 Class.forName(driver); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; //获取连接 public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, username, password); &#125; //释放资源 public static void release(Connection conn, Statement st, ResultSet rs)&#123; if(rs!=null)&#123; try &#123; rs.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; if(st!=null)&#123; try &#123; st.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; &#125; &#125; &#125; JavaMySql.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206package Base.CommunityManagementSystem;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Scanner;public class JavaMySql &#123; public static void Query(String sqlCmd) &#123;//查询所有信息:Query(String sqlCmd) Connection conn = null; Statement st = null; ResultSet rs = null; String name; try &#123; conn = JdbcUtils.getConnection(); //获取数据库连接 st = conn.createStatement(); //获得SQl执行对象 rs = st.executeQuery(sqlCmd); //查询完返回一个结果集 while (rs.next()) &#123; System.out.println(&quot;userNo\\tloginPwd\\tstudentName\\tsex\\tgradeId\\tphoneNum\\taddress\\tbornDate\\temail\\t\\tidentityId&quot;); System.out.print(&quot;\\t&quot; + rs.getObject(&quot;userNo&quot;) + &quot;\\t&quot;); System.out.print(rs.getObject(&quot;loginPwd&quot;) + &quot;\\t&quot;); //System.out.print(&quot;\\t\\t&quot; + rs.getObject(&quot;studentName&quot;) + &quot;\\t\\t&quot;); name = (String)rs.getObject(&quot;studentName&quot;); if(name.length()&lt;3) System.out.print(&quot;\\t\\t&quot; + rs.getObject(&quot;studentName&quot;) + &quot;\\t\\t&quot;); else System.out.print(&quot;\\t\\t&quot; + rs.getObject(&quot;studentName&quot;) + &quot;\\t&quot;); System.out.print(rs.getObject(&quot;sex&quot;) + &quot;\\t\\t&quot;); System.out.print(rs.getObject(&quot;gradeId&quot;) + &quot;\\t&quot;); System.out.print(rs.getObject(&quot;phoneNum&quot;) + &quot;\\t&quot;); System.out.print(rs.getObject(&quot;address&quot;) + &quot;\\t&quot;); System.out.print(rs.getObject(&quot;bornDate&quot;) + &quot;\\t&quot;); System.out.print(rs.getObject(&quot;email&quot;) + &quot;\\t&quot;); System.out.print(rs.getObject(&quot;identityId&quot;) + &quot;\\t\\n&quot;); System.out.println(&quot;------------------------------------------------------------------------------------&quot;); &#125;//查询 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JdbcUtils.release(conn, st, rs); &#125; &#125; public static void QueryUseInfo(String sqlCmd) &#123;//查询水电气信息:Query(String sqlCmd) Connection conn = null; Statement st = null; ResultSet rs = null; boolean flagFee; try &#123; conn = JdbcUtils.getConnection(); //获取数据库连接 st = conn.createStatement(); //获得SQl执行对象 rs = st.executeQuery(sqlCmd); //查询完返回一个结果集 while (rs.next()) &#123; System.out.println(&quot;userNo\\twater\\tnaturalGas\\telectricity\\t| waterCharge\\tnaturalGasCharge\\telectricityCharge\\t付费情况&quot;); System.out.print(rs.getObject(&quot;userNo&quot;) + &quot;\\t &quot;); System.out.print(rs.getObject(&quot;water&quot;) + &quot;\\t\\t\\t&quot;); System.out.print(rs.getObject(&quot;naturalGas&quot;) + &quot;\\t\\t\\t&quot;); System.out.print(rs.getObject(&quot;electricity&quot;) + &quot;\\t\\t\\t&quot;); System.out.print(rs.getObject(&quot;waterCharge&quot;) + &quot;\\t\\t\\t\\t\\t&quot;); System.out.print(rs.getObject(&quot;naturalGasCharge&quot;) + &quot;\\t\\t\\t\\t\\t&quot;); System.out.print(rs.getObject(&quot;electricityCharge&quot;) + &quot;\\t\\t&quot;); flagFee = (boolean) rs.getObject(&quot;expenseStatus&quot;); if(flagFee) System.out.println(&quot;已缴费\\n&quot;); else System.out.println(&quot;未缴费\\n&quot;); System.out.println(&quot;------------------------------------------------------------------------------------&quot;); &#125;//查询 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JdbcUtils.release(conn, st, rs); &#125; &#125;// public static int getWaterGasElectricity(int id)&#123;//// &#125; public static void Insert(String sqlCmd) &#123; //查询所有信息:&#x27;1008&#x27;,&#x27;123456&#x27;,&#x27;zhr&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;13379059095&#x27;,&#x27;陕西西安&#x27;,&#x27;1999-11-21&#x27;,&#x27;feoar@outlook.com&#x27;,&#x27;123456198654011234&#x27; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; conn = JdbcUtils.getConnection(); //获取数据库连接 st = conn.createStatement(); //获得SQl执行对象 if (st.executeUpdate(sqlCmd) &gt; 0) &#123; System.out.println(&quot;增改成功！&quot;); &#125;else System.out.println(&quot;ERROR&quot;); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JdbcUtils.release(conn, st, rs); &#125; &#125; public static void Delete(String sqlCmd) &#123; //查询所有信息:&#x27;1008&#x27;,&#x27;123456&#x27;,&#x27;zhr&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;13379059095&#x27;,&#x27;陕西西安&#x27;,&#x27;1999-11-21&#x27;,&#x27;feoar@outlook.com&#x27;,&#x27;123123498654011234&#x27; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; conn = JdbcUtils.getConnection(); //获取数据库连接 st = conn.createStatement(); //获得SQl执行对象 if (st.executeUpdate(sqlCmd) &gt; 0) &#123; System.out.println(&quot;删除成功！&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JdbcUtils.release(conn, st, rs); &#125; &#125; public static void Update(String sqlCmd) &#123; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; conn = JdbcUtils.getConnection(); //获取数据库连接 st = conn.createStatement(); //获得SQl执行对象 if (st.executeUpdate(sqlCmd) &gt; 0) &#123; System.out.println(&quot;修改成功！&quot;); //JavaMySql.Query(); &#125;else System.out.println(&quot;似乎失败了...&quot;); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JdbcUtils.release(conn, st, rs); &#125; &#125; public static void calculate() &#123; Connection conn = null; Statement st = null; ResultSet rs = null; String sqlCmd = &quot;SELECT SUM(water) waterAll,SUM(naturalGas) naturalGasAll,SUM(electricity) electricityAll FROM cost;&quot;; try &#123; conn = JdbcUtils.getConnection(); //获取数据库连接 st = conn.createStatement(); //获得SQl执行对象 rs = st.executeQuery(sqlCmd); //查询完返回一个结果集 while (rs.next()) &#123; System.out.println(&quot;waterALl\\tnaturalGasALl\\telectricityALl&quot;); //System.out.print(&quot;\\t&quot; + rs.getObject(&quot;studentNo&quot;) + &quot;\\t&quot;); //System.out.print(&quot;\\t\\t&quot; + rs.getObject(&quot;studentName&quot;) + &quot;\\t&quot;); //System.out.print(rs.getObject(&quot;sex&quot;) + &quot;\\t&quot;); System.out.print(rs.getObject(&quot;waterAll&quot;) + &quot;\\t\\t\\t&quot;); System.out.print(rs.getObject(&quot;naturalGasAll&quot;) + &quot;\\t\\t\\t\\t&quot;); System.out.print(rs.getObject(&quot;electricityAll&quot;) + &quot;\\t\\t\\t\\t\\n&quot;); System.out.println(&quot;------------------------------------------------------------------------------------&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JdbcUtils.release(conn, st, rs); &#125; &#125; public static void crateNewTable()&#123; Scanner Input = new Scanner(System.in); System.out.println(&quot;请输入要新建水电气用量表的日期：（202001）表示2020年1月&quot;); int month = Input.nextInt(); String monthTabName = &quot;Info&quot;+month; //前缀 Connection conn = null; Statement st = null; ResultSet rs = null; String sqlCmd =&quot;CREATE TABLE `&quot;+monthTabName+&quot;`(\\n&quot; + &quot;`userNo`INT(4) NOT NULL COMMENT &#x27;用户编号&#x27;,\\n&quot; + &quot;`water` INT(3) DEFAULT NULL COMMENT &#x27;用水量&#x27;,\\n&quot; + &quot;`naturalGas` INT(4) DEFAULT NULL COMMENT &#x27;用气量&#x27;,\\n&quot; + &quot;`electricity` INT(4) DEFAULT NULL COMMENT &#x27;用电量&#x27;,\\n&quot; + &quot;`waterCharge` INT(4) DEFAULT NULL COMMENT &#x27;水费&#x27;,\\n&quot; + &quot;`naturalGasCharge` INT(4) DEFAULT NULL COMMENT &#x27;燃气费&#x27;,\\n&quot; + &quot;`electricityCharge` INT(4) DEFAULT NULL COMMENT &#x27;电费&#x27;,\\n&quot; + &quot;`expenseStatus` BOOLEAN DEFAULT NULL COMMENT &#x27;付费情况&#x27;,\\n&quot; + &quot;PRIMARY KEY (`userNo`)\\n&quot; + &quot;)ENGINE = INNODB DEFAULT CHARSET = utf8;&quot;; try &#123; conn = JdbcUtils.getConnection(); //获取数据库连接 st = conn.createStatement(); //获得SQl执行对象 if (st.executeUpdate(sqlCmd) == 0) &#123; System.out.println(&quot;创建成功！&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JdbcUtils.release(conn, st, rs); &#125; &#125;&#125;https://imgchr.com/i/rRi11Ahttps://imgchr.com/i/rRilpd 数据库文件 在github自取吧 代码执行 首先我们要启动数据库（管理员模式） 1net start mysql 登录 12mysql -u root -p然后输入密码 使用数据库可视化管理软件连接到数据库（这只是为了方便观察数据变动，其实可以不用） 这里数据库已经建立并链接到了程序中，这是当前数据库中的表的情况。 运行程序！ 施工中！！！！","categories":[],"tags":[{"name":"基础学习","slug":"基础学习","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"BankerAlgorithm","slug":"BankerAlgorithm","date":"2020-12-26T16:00:00.000Z","updated":"2020-12-30T15:26:33.686Z","comments":true,"path":"2020/12/27/BankerAlgorithm/","link":"","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/2020/12/27/BankerAlgorithm/","excerpt":"","text":"BankerAlgorithm 我的操作系统课设，写的比较简单。。。 银行家算法 ， 安全检查 算法简介在多道程序系统中，虽可以借助多个进程的并发执行来改善系统的资源利用率，提高系统吞吐量，但可能发生一种危险——死锁，即多个进程在运行过程中因争夺资源而造成的一种僵局，若无外力作用，将无法再向前推进。如此，寻求一种避免死锁的方法便显得有为重要。死锁的产生一般的原因有两点:竞争资源和进程间推进顺序非法。因此，我们只需在当前的有限资源下，找到一组合法的执行顺序，便能很好的避免死锁，我们称它为安全序列。而银行家算法起源于银行系统的发放贷款，和计算机操作系统的资源分配完全符合，因此可以借鉴该算法的思想，设计出一种有效的算法程序，解决该问题。 程序思路 示例 Max Allocation Need 进程\\资源 A B C A B C A B C P0 7 5 3 0 1 0 7 4 3 P1 3 2 2 2 0 0 1 2 2 P2 9 0 2 3 0 2 6 0 0 P3 2 2 2 2 1 1 0 1 1 P4 4 3 3 0 0 2 4 3 1 可用资源（available）A, B, C = 3, 3, 2 程序运行 首先输入矩阵的相关信息 申请超过该进程的Need 申请超过Available 申请模拟分区配后不安全并退回 申请模拟分区配后安全并真实分配 进程获得所有Need后结束并退出安全序列 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242/* * _ooOoo_ * o8888888o * 88&quot; . &quot;88 * (| -_- |) * O\\ = /O * ____/`---&#x27;\\____ * .&#x27; \\\\| |// `. * / \\\\||| : |||// \\ * / _||||| -:- |||||- \\ * | | \\\\\\ - /// | | * | \\_| &#x27;&#x27;\\---/&#x27;&#x27; | | * \\ .-\\__ `-` ___/-. / * ___`. .&#x27; /--.--\\ `. . __ * .&quot;&quot; &#x27;&lt; `.___\\_&lt;|&gt;_/___.&#x27; &gt;&#x27;&quot;&quot;. * | | : `- \\`.;`\\ _ /`;.`/ - ` : | | * \\ \\ `-. \\_ __\\ /__ _/ .-` / / * ======`-.____`-.___\\_____/___.-`____.-&#x27;====== * `=---=&#x27; * ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ * 佛祖保佑 永无BUG * * @author FeAor * 2020/11/16:遗留问题：测试不同规格矩阵需求 * 2020/11/20:基本正常 */package src;import java.util.Arrays;import java.util.Scanner;public class main &#123; static int[][] array = new int[100][100]; static int[] available = new int[30]; static int[] need = new int[30]; static int[] request = new int[30]; static int process; static int processId; static int resource; static Scanner Input = new Scanner(System.in); public static void main(String[] args) &#123; System.out.println(&quot;进程数：(&lt;100)&quot;); process = Input.nextInt(); System.out.println(&quot;资源数：(&lt;30)&quot;); resource = Input.nextInt(); System.out.println(&quot;输入可用资源数&quot;); for (int i = 0; i &lt; resource; i++) &#123; available[i] = Input.nextInt(); &#125; System.out.println(&quot;输入最大需求矩阵&quot;); for (int i = 0; i &lt; process; i++) &#123; for (int j = 0; j &lt; resource; j++) &#123; array[i][j] = Input.nextInt(); &#125; &#125; System.out.println(&quot;输入分配矩阵&quot;); for (int i = 0; i &lt; process; i++) &#123; for (int j = resource; j &lt; 2*resource; j++) &#123; array[i][j] = Input.nextInt(); &#125; &#125; //计算需求矩阵 for (int i = 0; i &lt; process; i++) &#123; for (int j = 2*resource ,n = 0; j &lt; 3*resource; j++,n++) &#123; array[i][j] = array[i][n] - array[i][n+resource]; &#125; &#125; for (int i = 0; i &lt; process; i++) &#123; System.arraycopy(array[i], 0, array[i], 0, 3*resource); &#125;//备份一次 //显示基础信息，只运行一次 SecurityCheck(101); System.out.println(&quot;\\n&quot;); do &#123; System.out.println(&quot;========================================\\n可分配资源&quot;); for (int i = 0; i &lt; resource; i++) &#123; System.out.print(available[i]+&quot; | &quot;); &#125;System.out.println(&quot;\\n&quot;); Request(); //应该由具体函数操作调用 &#125; while (true); &#125; public static void Display()&#123; //输出矩阵 System.out.println(&quot;\\t|MAX |Alloc |Need |Flag&quot;); for (int i = 0; i &lt; process; i++) &#123; System.out.print(&quot;进程&quot;+i); for (int j = 0; j &lt;= 3*resource; j++) &#123; if(j%resource == 0) System.out.print(&quot;|&quot;); System.out.print(array[i][j]+&quot; &quot;); &#125; System.out.println(&quot;\\n&quot;); &#125; &#125; public static void Request()&#123; int sum = 0; int[] need = new int[request.length]; System.out.println(&quot;输入请求资源进程：&quot;); processId = Input.nextInt(); //指定进程名 System.out.println(&quot;输入请求资源数量：&quot;);//request for (int i = 0; i &lt; resource; i++) &#123; request[i] = Input.nextInt(); need[i] = array[processId][2*resource+i]; &#125; if(!bankersCompare(need,request))&#123; System.out.println(&quot;申请超需求，请重新输入&quot;); Request(); &#125;else&#123; for (int i = 0; i &lt; resource; i++) &#123;//此处对几大数组进行直接修改，需注意 available[i] -= request[i]; array[processId][i+resource] += request[i]; //allocation + request array[processId][i+2*resource] -= request[i]; //need - request &#125;//预分配若 need==0 available+。。。。 for (int i = 0; i &lt; resource; i++) &#123; sum += array[processId][2*resource+i]; //need求和 &#125; if(sum==0) &#123; for (int i = 0; i &lt; resource; i++) &#123; available[i] += array[processId][i]; //由于对available进行了修改，所以加的是max &#125; &#125; //以上else内对合法的request直接进行了分配 //然后进行安全检查 SecurityCheck(processId); &#125; &#125; public static void SecurityCheck(int processId)&#123;//int[] request Scanner Input = new Scanner(System.in); int[] work = Arrays.copyOf(available, resource); //创建work数组 int[] resourceNum = new int[resource]; boolean flag1 = false; boolean flag2 = false; int sum = 0; int sum2 = 0; int sum3 = 0; int flag3 = 0; int numComplete = 0; int times = 0; for (int i = 0; i &lt; process; i++) &#123; array[i][3*resource] = 0; &#125; //安全检查前先排除已经完毕的进程 for (int i = 0; i &lt; process; i++) &#123; for (int j = 0; j &lt; resource; j++) &#123; sum2 += array[i][2*resource+j];//need求和若为0则运行完成 &#125; if(sum2 == 0) numComplete++; else sum2 = 0; &#125; flag3 = process - numComplete; while(!flag2)&#123; //此处遍历为了不断循环直到找到整个安全序列 times++; sum3 = 0; numComplete = 0; for (int i = 0; i &lt; process; i++) &#123; sum3 += array[i][3*resource];//flag求和 &#125; flag2 = sum3 == flag3;//此处检查是否全部运行过 for (int i = 0; i &lt; process; i++) &#123; //遍历检查 sum = 0; for (int k = 0; k &lt; resource; k++) &#123; need[k] = array[i][2*resource+k]; //设置一下need sum += array[i][2*resource+k]; //need求和看是否完成 &#125; if(sum &gt; 0)&#123; if(array[i][3*resource] == 0 &amp;&amp; bankersCompare(work,need))&#123; //判断目前进程i是否满足需求 for (int j = 0; j &lt; resource; j++) &#123; work[j] += array[i][resource+j]; //改变work,work + allocation &#125; array[i][3*resource] = 1; //改变标志，即finish System.out.print(&quot;(&quot;+i+&quot;)--&gt;&quot;); //从头开始找 &#125; &#125; &#125; if( times&gt;process-numComplete)&#123; flag1 = true; //此处两个flag，两种跳出机制 break; &#125;else flag1= false; &#125; System.out.println(&quot;\\n&quot;); if(flag1)&#123; System.out.println(&quot;&lt;&lt;不安全,已退回&gt;&gt;&quot;); for (int i = 0; i &lt; resource; i++) &#123; //此处对几大数组进行直接修改，需注意（退回操作） available[i] += request[i]; array[processId][i+resource] -= request[i]; array[processId][i+2*resource] += request[i]; &#125; &#125; else System.out.println(&quot;&lt;&lt;安全&gt;&gt;&quot;); for (int j = 0; j &lt; process; j++) &#123; array[j][3*resource] = 0; &#125; for (int i = 0; i &lt; resource; i++) &#123; System.out.print(available[i]+&quot; | &quot;); &#125;System.out.println(&quot;\\n&quot;); Display(); &#125; public static boolean bankersCompare(int[] a,int[] b)&#123; int flag = 0; for (int i = 0; i &lt; a.length; i++) &#123; if(a[i] &gt;= b[i]) flag++; else flag--; &#125; return flag == a.length; &#125;&#125; 备注程序还有一点缺陷，比如特殊规格的矩阵，输入的合法判断等。有需要自行完善吧","categories":[],"tags":[{"name":"基础学习","slug":"基础学习","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"MySQL简略笔记","slug":"MySql简略笔记","date":"2020-10-25T16:00:00.000Z","updated":"2020-11-02T03:23:34.121Z","comments":true,"path":"2020/10/26/MySql简略笔记/","link":"","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/2020/10/26/MySql%E7%AE%80%E7%95%A5%E7%AC%94%E8%AE%B0/","excerpt":"","text":"MySQL简略笔记基本 启动 1net start mysql 登录 1mysql -u root -p --连接数据库 退出 1exit; --推出连接 其他 12345678-- 所有语句使用&#x27; ; &#x27;结尾show databases; --查看所有数据库show tables; --查看所有表describe student; --查看数据库中所有表的信息creat database teacher; --船舰一个teacher数据库use school --切换数据库 数据库语言 DDL 定义 DML 操作 DQL 查询 QCL 控制 操作（了解） 创建数据库 1CREATE DATABASE [IF NOT EXISTS] company; --中括号内为可选 移出数据库 1DROP DATABASE [IF EXISTS] company; 使用数据库 123-- tab键上方的符号，若表命或字段名是特殊字符，就需要带 ` `--eg.SELECT `USER` --此处user相当于一个java保留字，需要带``区别 查看所有数据库 1SHOW DATABASE 数据库列类型 数值 tinyint 非常小的数据 1字节 smallint 较小的数据 2字节 mediumint 中等大小的数据 3字节 int 标准整数 4字节 bigint 较大的数据 8字节 float 单精度浮点数 4字节 double 双精度浮点数 8字节（精度问题） decimal 字符串形式浮点数 （金融计算一般使用） 字符串 char 固定大小字符串 0-255 verchar 可变字符串 0-65535 对应Java的String 常用 tinystext 微型文本 2^8 - 1 text 文本串 2^16 - 1 保存大文本 时间日期 date YYYY-MM-DD, 日期格式 time HH: mm: ss, 时间格式 datetime YYYY-MM-DD HH: mm: ss 最常用的时间格式 timestamp 时间戳，1970/1/1至今的毫秒数，常用 year 年份表示 NULL 无值，未知 不应使用NULL运算 数据库的字段属性（重点） Unsigned： 无符号的整数列 声明该列不能声明为负数 zerofill 不足位数以 0 填充 AUTO_INCREMENT 自动带上一条记录的基础上+1（默认） 通常用来设计唯一的主键，（主键整数类型） 可自定义主键自增的起始值与步长 非空 不填值则报错 默认 不指定该列的值则会有默认值 创建表1234567891011--eg.CREATE TABLE IF NOT EXISTS `student`( `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;, /*COMMENT注释*/ `name` VARCHAR(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;, `pwd` VARCHAR(20) NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27;密码&#x27;, `sex` VARCHAR(2) NOT NULL DEFAULT &#x27;男&#x27; COMMENT &#x27;性别&#x27;, `birthday` DATETIME DEFAULT NULL COMMENT &#x27;出生日期&#x27;, `address` VARCHAR(100) DEFAULT NULL COMMENT &#x27;家庭住址&#x27;, `email` VARCHAR(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, PRIMARY KEY(`id`))ENGINE=INNODB DEFAULT CHARSET=utf8 格式 12345678CREATE TABLE [IF NOT EXISTS] `表名`( `字段名` 列类型 [属性][索引][注释], `字段名` 列类型 [属性][索引][注释], `字段名` 列类型 [属性][索引][注释], `字段名` 列类型 [属性][索引][注释], .... `字段名` 列类型 [属性][索引][注释])[表类型][字符集设置][注释] 查看创建结构语句 SHOW CREATE DATABASE school –创建数据库 SHOW CREATE TABLE student –创建表 DESC student –显示表的结构 修改删除表123456789ALTER TABLE teacher RENAME AS teacher1 --修改表名ALTER TABLE teacher ADD age INT(11) --增加字段ALTER TABLE teacher MODIFY age VARCHAR(11) --修改约束ALTER TABLE teacher CHANGE age age1 INT(11) --字段重命名ALTER TABLE teacher DROP age --删除字段DROP TABLE IF EXISTS teacher --删除表 数据库在物理空间的存储 所有文件都在data目录下，本质还是属于文件的存储 MySQL引擎在物理文件上的区别 InnoDB在数据库表中只有一个*.frm文件，以及上级目录下的 ibdate1文件 MyISAM *.frm - 表结构定义文件 *.MYD - 数据文件（data） *.MYI - 所有文件（index） 关于数据库引擎 InnoDB（事务支持，数据行锁定，外键约束，表空间较大约为MYISAM两倍）安全性高，事务的处理，多表多用户操作 MyISAM（支持全文索引，表空间较小）节约空间，速度较快 MySQL数据管理外键（了解即可） 在建表时创建外键（不建议） 建表后单独创建 alter table 表 add constraint 约束名 foreign key （作为外键的字段）references 另一个表（相应字段） 以上都是物理外键，数据库级别，不建议使用 DML语言（记忆） 插入 12345678910INSERT INTO `表命`(`字段1`,`字段2`,`字段3`) VALUES(&#x27;值1&#x27;),(&#x27;值2&#x27;),(&#x27;值3&#x27;)此处为插入多条数据INSERT INTO `表命`(`字段1`,`字段2`,`字段3`) VALUES(&#x27;值1&#x27;,&#x27;值2&#x27;,&#x27;值3&#x27;), (&#x27;值4&#x27;,&#x27;值5&#x27;,&#x27;值6&#x27;), (&#x27;值7&#x27;,&#x27;值8&#x27;,&#x27;值9&#x27;) --注意对应INSERT INTO `grade`(`gradename`) VALUES(&#x27;大一&#x27;)--若不写字段名则需要输入全信息，并且一一对应 修改 12--修改学生姓名,带条件UPDATE `student` SET `name`=&#x27;FeOAr&#x27; WHERE id = 1; 删除 DELETE命令 12--delete from 表名 （where 条件），不加条件则全部删除,表结构索引约束不变DELETE FROM `student` WHERE id = 1; delete重启数据库，问题：InnoDB自增列从1开始（存在RAM中，断电即失） MyISAM ：继续从上一个量开始（存在文件中，不会丢失） TRUNCATE命令：完全清空一个数据库，表结构索引约束不变 会重置自增列，计数器归零 不会影响事务 1TRUNCATE `student` DQL查询数据函数 Concat(a,b)： SELECT CONCAT(‘姓名：’,StudentName) AS 姓名 FROM student Distinct去重 SELECT DISTINCT ‘StudentNo’ FROM result 联表查询JoinON详解 7种Join 自连接分页与排序MySQL函数 常用函数 数学运算 12345SELECT ABS() --绝对值SELECT CEILING() --向上取整SELECT FLOOR() --向下取整SELECT RAND() --返回一个0-1之间的随机数SELECT SIGN() --判断一个数符号，附属返回-1，正数返回1 字符串函数 1234567SELECT CHAR_LENGTH(&#x27;字符串&#x27;) --字符串长度SELECT CONCAT(&#x27;字符串1&#x27;,&#x27;字符串2&#x27;) --拼接字符串SELECT INSERT() --查询替换(格式：insert(str,pos,len,newstr))从某个位置开始替换某个长度SELECT LOWER() --转小写SELECT UPPER() --转大写SELECT INSTRT() --返回特定字符串第一次出现的位置，格式：instr(str,substr)SELECT REPLACE() --替换出现的指定字符串，格式：(字符串，要替换的，替换成的) 日期和时间 123456789101112SELECT CURRENT_DATE() --获取当前日期SELECT CURDATE() --获取当前日期与上相同SELECT NOW() --获取当前时间SELECT LOCALTIME() --本地时间SELECT SYSDATE() --系统时间SELECT YEAR(NOW())SELECT MONTH(NOW())SELECT DAY(NOW())SELECT HOUR(NOW())SELECT MINUTE(NOW())SELECT SECOND(NOW()) 系统 123SELECT SYSTEM_USER()SELECT USER()SELECT VERSION() 聚合函数 COUNT() 计数 SUN() 求和 AVG() 平均值 MAX() 最大值 MIN() 最小值 … … 12--eg.SELECT COUNT(studentname) FROM student; 聚合函数及分组过滤拓展之数据库级别的MD5加密select小结事务事务ACID原则，脏读，不可重复读，幻读测试事务实现转账索引索引介绍及索引的分类索引原则和明日安排数据库用户管理权限管理与备份MySQL备份如何设计一个项目的数据库数据库三大范式数据库驱动和JDBC数据库驱动 程序 —&gt;(数据库驱动)—&gt; 数据库 JDBC Java操作数据库的规范，对于开发人员掌握JDBC的接口即可，本质就是一套接口 数据库驱动包 Java.sql Javax.sql 123456789101112131415161718192021222324252627282930313233343536//实例package base.learnjdbc.first;import java.sql.*;public class JdbcFirst &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //1.加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//固定写法，加载驱动 //2.用户信息和url String url = &quot;jdbc:mysql://localhost:3306/school?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&quot;; String username = &quot;root&quot;; String password = &quot;123456&quot;; //3.连接成功,connection代表数据库 Connection connection = DriverManager.getConnection(url,username,password); //4.执行SQL的对象 Statement statement = connection.createStatement(); //5.执行SQL的对象去执行SQL，查看结果 String sql = &quot;SELECT * FROM student&quot;; ResultSet resultSet = statement.executeQuery(sql); while( resultSet.next())&#123; System.out.println(&quot;studentno&quot;+resultSet.getObject(&quot;studentno&quot;)); System.out.println(&quot;loginpwd&quot;+resultSet.getObject(&quot;loginpwd&quot;)); System.out.println(&quot;studentname&quot;+resultSet.getObject(&quot;studentname&quot;)); System.out.println(&quot;phone&quot;+resultSet.getObject(&quot;phone&quot;)); System.out.println(&quot;----------------------------&quot;); &#125; //6.释放连接 resultSet.close(); statement.close(); connection.close(); &#125;&#125; Statement对象详解 Jdbc中的statement对象用于向数据库发送SQL语句，想要完成对数据库的增删改查只需要通过这个对象向数据库发送增删改查语句即可。 Statement.executeUpdate方法用于向数据库发送增删改查的SQL语句executeUpdate方法执行完后，将会返回一个整数（即增删改查操作导致有多少行数据发生了变化） 用于执行 INSERT、UPDATE 或 DELETE 语句以及 SQL DDL（数据定义语言）语句，例如 CREATE TABLE 和 DROP TABLE。INSERT、UPDATE 或 DELETE 语句的效果是修改表中零行或多行中的一列或多列。executeUpdate 的返回值是一个整数，指示受影响的行数（即更新计数）。对于 CREATE TABLE 或 DROP TABLE 等不操作行的语句，executeUpdate 的返回值总为零。 参考链接 12345678910111213141516171819202122232425262728293031--增Statement st = conn.createStatement();String sql = &quot;insert into student(...)values(...)&quot;;int num = st.executeUpdate(sql);if(num&gt;0)&#123; System.out.println(&quot;插入成功！！&quot;);&#125;--删Statement st = conn.createStatement();String sql = &quot;delete from student where id = 1&quot;;int num = st.executeUpdate(sql);if(num&gt;0)&#123; System.out.println(&quot;删除成功！！&quot;);&#125;--改Statement st = conn.createStatement();String sql = &quot;update student set name=&#x27;&#x27;where name=&#x27;&#x27;&quot;;int num = st.executeUpdate(sql);if(num&gt;0)&#123; System.out.println(&quot;修改成功！！&quot;);&#125;--增Statement st = conn.createStatement();String sql = &quot;insert into student(...)values(...)&quot;;int num = st.executeUpdate(sql);if(num&gt;0)&#123; System.out.println(&quot;插入成功！！&quot;);&#125; Statement.executeQuery方法用于向数据库发送查询语句，executeQuery方法返回代表查询结果的ResultSet对象 1234567--查Statement st = conn.createStatement();String sql = &quot;select * from student where id = 1&quot;;ResultSet rs = st.executeQuery(sql);while(rs.nest)&#123; //根据数据类型，分别调用rs的相应方法应涉及到java对象中&#125; 提取工具类 12345#db.propertiesdriver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/school?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=trueusername=rootpassword=123456 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//JdbcUtils.javapackage base.learnjdbc.first;import java.io.IOException;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JdbcUtils &#123; private static String driver =null; private static String url =null; private static String username =null; private static String password =null; static &#123; try &#123; InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;); Properties properties = new Properties(); properties.load(in); driver = properties.getProperty(&quot;driver&quot;); url = properties.getProperty(&quot;url&quot;); username = properties.getProperty(&quot;username&quot;); password = properties.getProperty(&quot;password&quot;); //1.驱动只加载一次 Class.forName(driver); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; //获取连接 public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, username, password); &#125; //释放资源 public static void release(Connection conn, Statement st, ResultSet rs)&#123; if(rs!=null)&#123; try &#123; rs.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; if(st!=null)&#123; try &#123; st.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 测试 1234567891011121314151617181920212223242526272829303132333435363738package base.learnjdbc.first;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class test &#123; public static void main(String[] args) &#123; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; conn = JdbcUtils.getConnection(); //获取数据库连接 st = conn.createStatement(); //获得SQl执行对象 //String sql = &quot;SELECT `phone` FROM student where sex = 0&quot;; String sql = &quot;INSERT INTO student (studentno,`loginpwd`,`studentname`,`sex`,`gradeid`,`phone`,`address`,`borndate`,`email`,`identitycard`)\\n&quot; + &quot;VALUES (1002,&#x27;123456&#x27;,&#x27;zhr&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;13379059095&#x27;,&#x27;陕西西安&#x27;,&#x27;1999-11-21&#x27;,&#x27;feoar@outlook.com&#x27;,&#x27;123456198654011234&#x27;)&quot;; int i = st.executeUpdate(sql); if(i&gt;0)&#123; System.out.println(&quot;插入成功！&quot;); &#125;// rs = st.executeQuery(sql); //查询完返回一个结果集//// while( rs.next())&#123;// System.out.println(&quot;phone\\n&quot;+rs.getObject(&quot;phone&quot;)+&quot;\\t&quot;);// System.out.println(&quot;----------------------------&quot;);// &#125;//查询 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally&#123; JdbcUtils.release(conn,st,rs); &#125; &#125;&#125; SQL注入问题 sql存在漏洞会被攻击，数据泄露。SQL会被拼接 12345678910111213141516171819202122232425262728293031323334353637//eg.package base.learnjdbc.first;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class SQLzhuru &#123; public static void main(String[] args) &#123; //正常login(&quot;zhr&quot;,&quot;123456&quot;); login(&quot;&#x27;or&#x27;1=1&quot;,&quot;&#x27;or&#x27;1=1&quot;); &#125; public static void login(String username,String password)&#123; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; conn = JdbcUtils.getConnection(); //获取数据库连接 st = conn.createStatement(); //获得SQl执行对象 //String sql = &quot;SELECT * FROM student WHERE `studentname` = &#x27;zhr&#x27; AND `loginpwd` = &#x27;123456&#x27;&quot;; String sql = &quot;SELECT * FROM student WHERE `studentname` = &#x27;&quot;+username+&quot;&#x27; AND `loginpwd` = &#x27;&quot;+password+&quot;&#x27;&quot;; rs = st.executeQuery(sql); //查询完返回一个结果集 while( rs.next())&#123; System.out.println(rs.getObject(&quot;studentname&quot;)); System.out.println(rs.getString(&quot;loginpwd&quot;)); &#125;//查询 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally&#123; JdbcUtils.release(conn,st,rs); &#125; &#125;&#125; PreparedStatement对象 PreparedStatement可以防止SQL注入且效率更高 增 删 改 查 使用IDEA连接数据库JDBC操作事务DBCP-C3P0连接池起因：数据库连接–执行完毕–释放，过程十分浪费资源 池化技术：准备一些预先资源，直接连接准备好的","categories":[],"tags":[{"name":"基础学习","slug":"基础学习","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"常用命令","slug":"常用命令行","date":"2020-10-12T16:00:00.000Z","updated":"2020-10-13T05:21:19.489Z","comments":true,"path":"2020/10/13/常用命令行/","link":"","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/2020/10/13/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/","excerpt":"","text":"常用命令 盘符切换 E: 查看当前目录下所有文件 dir 切换目录 cd (change directory) cd /d E:\\file (其中 /d 为跨盘符指令) cd ..（返回上级） 清理屏幕 cls（clean screen） 退出 exit 查看IP ipconfig 打开计算器 calc 记事本 notepad ping ping www.bilibili.com 创建文件夹 md test 新建文件 cd&gt;a.txt 删除 del a.txt 删除目录 rd test","categories":[],"tags":[{"name":"基础学习","slug":"基础学习","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"稀疏数组","slug":"稀疏数组","date":"2020-10-09T16:00:00.000Z","updated":"2020-10-10T14:00:50.625Z","comments":true,"path":"2020/10/10/稀疏数组/","link":"","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/2020/10/10/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/","excerpt":"","text":"稀疏数组 当一个数组中大部分元素为0，或者为同一值的数组时，可以使用吸收叔叔组来保存该数组。 稀疏数组的处理方式时： 记录数组一共有几行几列，有多少个不同的值 八级有不同值的元素和行列及值记录在一个小规模数组中，从而缩小程序规模 如图，左边为原始数组，右边为稀疏数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package Base.First.Demo;public class xishushuzu &#123; public static void main(String[] args) &#123; //创建一个11*11的二维数组 //0：没有棋子，1：黑棋，2：白棋 int[][] array1 = new int[11][11]; array1[1][2] = 1; array1[2][3] = 2; //输出原始数组 System.out.println(&quot;输出原始数组&quot;); for(int[] ints : array1)&#123; for(int anInt : ints)&#123; System.out.print(anInt + &quot;\\t&quot;); &#125; System.out.println(); &#125; //转换为稀疏数组 //获取有效值的个数 int sum = 0; for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if((array1[i][j]) != 0) sum++; &#125; &#125; System.out.println(&quot;--------------分割线----------------&quot;); System.out.println(&quot;有效值的个数= &quot; + sum); //创建一个稀疏数组对应的数组 int[][] array2 = new int[sum+1][3]; array2[0][0] = 11; array2[0][1] = 11; array2[0][2] = sum; //遍历二维数组，将非零值存入数组 int count = 0; for (int i = 0; i &lt; array1.length; i++) &#123; for (int j = 0; j &lt; array1[i].length; j++) &#123; if(array1[i][j] != 0)&#123; count++; array2[count][0] = i; array2[count][1] = i; array2[count][2] = array1[i][j]; &#125; &#125; &#125; //输出稀疏数组 System.out.println(&quot;输出稀疏数组&quot;); for (int i = 0; i &lt; array2.length; i++) &#123; System.out.println(array2[i][0] + &quot;\\t&quot; +array2[i][1]+ &quot;\\t&quot; +array2[i][2]+ &quot;\\t&quot;); &#125; System.out.println(&quot;--------------分割线----------------&quot;); //还原稀疏数组，1，读取稀疏数组 int[][] array3 = new int[array2[0][0]][array2[0][1]]; //给其中的元素还原其值 for (int i = 1; i &lt; array2.length; i++) &#123; array3[array2[i][0]][array2[i][1]] = array2[i][2]; &#125; //输出 System.out.println(&quot;还原的数组&quot;); for (int[] ints: array3) &#123; for(int anInt : ints)&#123; System.out.print(anInt + &quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"基础学习","slug":"基础学习","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Java学习","slug":"Java学习pro版","date":"2020-10-07T16:00:00.000Z","updated":"2020-11-02T04:50:18.980Z","comments":true,"path":"2020/10/08/Java学习pro版/","link":"","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/2020/10/08/Java%E5%AD%A6%E4%B9%A0pro%E7%89%88/","excerpt":"","text":"Java基础语法注释，标识符，关键字Java注释 单行注释 多行注释 文档注释 Java标识符关键字 标识符 类名，变量名，方法名都称为标识符。 数据类型 强类型语言 Java数据类型有两类 基本类型（primitive type） 引用类型（reference type） boolean (true/false&lt;—defaule) 1boolean flag = true; byte (节约空间) short / int / long 123456789101112131415161718//eg.long c1 = 100324532456L //进制拓展 二进制0b 八进制0 十进制 十六进制0xint i = 10;int i2 = 010; //八进制int i3 = 0x10; //十六进制System.out.println(i);System.out.println(i2);System.out.println(i3);//JDK7以后，数字之间可以加下划线分割int money = 10_0000_0000;int a = 20;long b = a * money; //b会溢出解决方法 -&gt; long b = a * (long)money;或 int money = 10_0000_0000L;P.S. &#x27;L&#x27;一般大写 float / double 123float f1 = 1.23fdouble d1 = 4.457d// 浮点数有损失，可以尝试使用BigDecimal 数学工具类 char ( \\u0000 - \\uffff || Unicode编码 2字节 || String属于类) 1char c3 = &#x27;\\u0061&#x27; 整数数拓展 浮点数拓展 字符拓展 12String s;s.equals(&quot;hello&quot;); //判断字符串s和hello是否相等 强制转换 （类型）变量名 转义字符 基本类型（一种变量）—-&gt; 结构体 （多种变量捆绑） —-&gt; 类（多种变量 + 方法） 类型转换 低 ——–（自动）———–&gt; 高（字节） ​ &lt;——–（强制）———– byte, short, char —&gt; int —&gt; long —&gt; float —&gt; double (小数优先级大于整数) 123456/*1.不能转换布尔值2.不能将对象类型转换为不相干的类型3.高容量转低容量时，强制转换4.转换时可能存在内存溢出或精度问题*/ 变量常量==不建议一行定义多个变量== 类变量 实例变量 局部变量 类成员变量：首字母小写和驼峰原则 局部变量：首字母小写和驼峰原则 常量 (final) ：大写字母和下划线 类名：首字母小写和驼峰原则 方法名：首字母小写和驼峰原则 运算符 包机制，JavaDoc包机制 package pk1[. pkg2[. pkg3…….]] eg. com.baidu.www ———&gt; com\\baidu\\www import package1[.package2….].(classname|*); eg. import com. baidu. www. *; JavaDoc JavaDoc命令是用来生成自己的API文档 API: API（Application Programming Interface，应用程序接口）是一些预先定义的函数，或指软件系统不同组成部分衔接的约定。 [1] 用来提供应用程序与开发人员基于某软件或硬件得以访问的一组例程，而又无需访问源码，或理解内部工作机制的细节。 1234567891011121314151617181920//eg.package Base.First.Demo;/** * @author zhr * @version 1.0 */public class Demo01 &#123; String name; /** * * @param name * @return * @throws Exception */ public String test(String name) throws Exception&#123; return name; &#125;&#125; 具体参考 Java流程控制用户交互Scanner Scanner s = new Scanner(System.in); 通过Scanner类的next() 与 nextLine() 方法获取输入字符串，在读取前一般使用hasNext() 与hasNextLine()判断是或否还有输入的数据。 1234567891011121314151617181920package Base.First.Demo;import java.util.Scanner;public class Scanne &#123; public static void main(String[] args) &#123; //创建一个扫描器对象，用于接收键盘数据 Scanner scanner = new Scanner(System.in); //判断用户有没有输入字符串 System.out.println(&quot;INPUT by next:&quot;); if(scanner.hasNext())&#123; //使用next方式接收 String str = scanner.next(); System.out.println(&quot;OUTPUT:&quot; + str); &#125; //凡是属于IO流的类如果不关闭会一直占用资源 scanner.close(); &#125;&#125; 顺序结构选择结构 if switch switch语句中变量类型可以是byte, short, int, char, String(from Java SE 7) switch中string 通过哈希值来匹配 循环结构==尽量避免死循环== while while(为假跳出){ } 先判断后执行 do…while 对比while，至少执行一次 先执行后判断 for 是支持迭代的一种通用结构，是最有效最灵活的循环结构，执行次数在执行前就已确定。 Idea_Tips: 100.for 123for (int i1 = 0; i1 &lt; 100; i1++) &#123; &#125; 遍历数组 1234int[] number = &#123;1,2,3,4,5&#125;; for(int x:number)&#123; System.out.println(x); &#125; break &amp; continue练习Java方法什么是方法 Java方法是解决一类问题的步骤的有序组合，方法包含于类或对象中，方法在程序中被创建，在其他地方被引用。 建议保证方法的原子性（一个函数，一个功能） 尽量保证main();的整洁干净 方法的定义以及调用定义 方法即函数，是一段用来完成特定功能的代码片段，一般情况下定义一个方法包含： 修饰符：可选 返回值类型 方法名 参数类型 方法体 123456修饰符 返回值类型 方法名（参数类型 参数名）&#123; ... 方法体 ... return 返回值;&#125; 调用 对象名.方法名（实参列表） Java属于值传递（值传递 / 引用传递） 方法重载 重载就是在一个类中，有相同的函数名称，但形参不同的函数，返回类型无所谓 令行传参 src目录下，Java 包名 + 文件名 可变参数 Java1.5开始支持传递同类型的可变参数给一个方法 在方法声明名中，在指定参数类型后加一个省略号”…” 一个方法中只能指定一个可变参数，且必须是最后一个参数。任何普通参数都必须在其之前声明。 1public static int add(int... i)&#123;&#125; 递归 123456789101112package Base.First.Demo;public class digui &#123; //阶乘 public static void main(String[] args) &#123; System.out.println(f(3)); &#125; public static int f(int n)&#123; if(n == 1) return 1; else return n*f(n-1); &#125;&#125; 都是栈机制，避免太深的递归 数组什么是数组 数组声明创建 dataType[] arrayRefVar; 或 dataType arrayRefVar[]; ( 效果相同不推荐 ) 语法：dataType[] arrayRefVar = new dataType[arraySize]; 获取数组长度： arrays.length 数组使用及内存分析使用 For - Each循环 12345int []a=&#123;1,2,3,4,5&#125;for(int b:a)&#123; System.out.println(b);&#125; 数组做方法入参 数组做返回值 数组变量赋值后管理同一个数组。 12int []a=&#123;1,2,3,4,5&#125;int []b=a; //修改b，a也改变 静态初始化：创建+赋值 多维数组Arrays类 数组的工具类java.util.Arrays，帮助对数组进行一些基本操作 Arrays类中的方法都是static修饰的静态方法，在使用时可以直接使用类名进行调用，”不强制用”使用对象来调用 常用方法： 给数组赋值：fill 给数组排序：sort，升序 比较数组：通过equals比较数组中元素值是否相等 查找数组元素：通过binarySearch方法能对排序好的数组二分法查找操作 12345678910111213//示例package Base.First.Demo;import java.util.Arrays;public class digui &#123; public static void main(String[] args) &#123; int []a=&#123;1,2,3,4,5&#125;; System.out.println(Arrays.toString(a)); &#125;&#125; 稀疏数组（具体参考该篇博客笔记） 面向对象面向对象 面向过程 步骤清晰简单，适合处理简单问题 面向过程 物以类聚，分类 的思维模式，解决问题前先对问题进行细分为类，对每个分类单独思考，再在单独分类下进行面向过程的思考。 适合处理复杂问题 对于描述复杂的事物，为了从宏观上把握，从整体上分析，我们需要使用面向对象的思路来分析整个系统。但是，具体的微观操作，仍需要面向过程的思路处理。 面向对象编程的本质就是：以类的方式组织代码，以对象的方式组织（封装）数据。 抽象 三大特性：封装，继承，多态 对象是类的具体表现 在程序中，先有类后有对象 方法（定义，调用） 静态方法，可以直接通过（类名.函数名）调用 非静态方法，必须将类实例化，（对象名.函数名）调用 形参实参 值传递与引用传递 this关键字 构造器 使用new关键字本质是在调用构造函数（构造器） 用来初始化值 IDEA中（ALT + INSERT）自动生成构造器 注意：定义有参构造函数后若要使用无参构造函数必须显示的（专门写一个无参构造函数）定义一个无参构造函数 this. (此处this一般指当前类) = （传入值） 封装 属性私有，get / set 高内聚，低耦合（类的内部数据操作细节自己完成，仅暴露少量的方法给外部使用） 继承 extands 意思是“扩展”，子类是父类的扩展，派生类为基类的扩展 继承是类之间的一种关系，除此之外还有以来，组合，聚合等 12//eg.public class Student extends Person&#123;&#125; 子类可以继承父类的所有方法（公有继承）,私有属性无法继承 Tips：CTRL + H 在IDEA中打开继承树 Java中所有类都默认直接或间接继承Object类，（祖宗类） Java 每个类只能继承一个类（单根继承原则） 若不写extends , Java都默认继承 Java.lang.Object 类 super(); 先调用父类的无参构造函数再调用自己的无参构造函数。 必须只能出现在子类的方法或构造函数中 super与this不能同时调用构造方法 super(一个形参); 先调用父类的一参构造函数再调用自己的一参构造函数。 。。。 父类没有无参构造函数则子类也没有 重写（override） 重写都是方法的重写，与属性无关 重写在子父类之间，定义必须相同，方法体不同；重载在一个类中 修饰符范围可以扩大但不能缩小（public &gt; protected &gt; default &gt; private） 抛出异常：范围可以缩小但不能扩大；eg. ClassNotFoundException -&gt; Exception(大) 静态方法与非静态方法 静态方法：方法的调用只和左边定义的数据类型有关，对象能执行哪些方法，主要看对象左边的类型与右边关系不大 非静态：重写 多态* 同一个方法可以根据发送对象的不同而采取多种不同的行为方式 多态是方法的多态，属性没有多态 一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多 存在的条件：继承关系，子类重写父类的方法，父类引用指向子类对象。Father f1 = new Son(); Tips : static方法属于类，不属于实例 final : 常量 private方法 类型转换带来的作用就是多态 子类继承父类所有的方法，但是子类可以重新定义一个名字，参数和父类一样的方法，该行为叫重写（覆写，覆盖，overwrite / override , not overload(重载)） 子类方法优先级高于父类 多态的作用 以统一的接口来操纵某一类中不同对象的动态行为 对象之间的解耦 Instanceof 判断一个对象是什么类型 12boolean result = obj instanceof Class //obj 为一个对象，Class 表示一个类或者一个接口当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。 具体参考 类转型 类型可以相互转型，但是只限制于有继承关系的类。 子类可以单向转化为父类（由大到小，向上转型） 1Human obj1 = new Man(); //Man extends Human 父类转为子类只有一种情况即该父类本身就从子类转化而来。 static 属性，类中只有一个，所有对象共同访问 方法，非静态方法可以直接调用静态方法，反之不行。因为static方法同类一起加载顺序在非静态之前 非静态需要用对象访问，静态可以直接类名访问，一般建议类名访问，方便看出为静态 static 静态的，Java中特殊的关键字（内存里只有一块） 可以作用在 变量，方法，类，匿名方法块 static块，只执行一次，执行顺序：static块 &gt; 匿名块 &gt; 1234567&#123; System.out.print(&quot;代码块&quot;);&#125;static&#123; System.out.print(&quot;静态代码块&quot;);&#125; 静态导入包 12345import static java.lang.Math.random . . .System.out.print(random()); //此处random函数如果没有导入，形式为Math.random() 抽象类 函数缺少函数体，该类需定义为抽象类。 关键字 abstract 可以用来修饰方法也可以用来修饰类，可以得到抽象方法，抽象类 123456//示例public abstract class Shape&#123; int area; public abstract void calRrea(); //抽象方法（函数），有一个就属于抽象类，具体类不加 abstract&#125; 抽象类无法 new创建对象，它是用来让子类继承的 抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的 抽象类也是类 抽象类中可以没有抽象方法，但由抽象方法的类一定要声明为抽象类 子类可以继承于抽象类，但一定要实现父类所有 abstract 的方法。若无法完全实现，子类也必须被定义为抽象类，只有实现父类所有 abstract 的方法才可变为完整类。 接口 如果所有方法都未实现，此类算是 接口 关键字 interface 1234//示例public interface Animal&#123; void name(String n);&#125; 普通类：只有具体实现 抽象类：具体实现和规范（抽象方法）都有 接口：只有规范接口本质是契约 类只可以继承一个类但可实现多个接口，继承（extends）与实现可以同时进行（弥补单根继承的不足） 实现（implements）一个接口必须实现所有的 abstract 方法 接口可继承多个接口 抽象类有构造函数，接口没有 抽象类可以有main，可运行，接口没有main 抽象类方法可以是private/protected，接口都是 public 接口作用 约束 定义方法，让不同人实现 public abstract public static final 接口不能被实例化，接口中没有构造方法 implements可以实现多个接口 必须要重写接口中的方法 内部类 内部类就是在一个类内部定义一个类 分为 成员内部类 静态内部类 局部内部类 匿名内部类 12345678910111213141516171819202122232425262728293031323334353637//实例//Outer.javapackage Base.First.Demo;public class Outer &#123; private int id= 10010; public void out()&#123; System.out.println(&quot;这是外部类方法&quot;); &#125; public class Inner&#123; public void in()&#123; System.out.println(&quot;这是内部类方法&quot;); &#125; //获得外部类的私有属性,若内部类为static则无法获取 public void getId()&#123; System.out.println(id); &#125; &#125;&#125;//Application.javapackage Base.First.Demo.Base;import Base.First.Demo.Outer;public class Application &#123; public static void main(String[] args) &#123; Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); outer.out(); inner.in(); inner.getId(); &#125;&#125; 一个Java文件中只能有一个 public class，但可以有多个class类 12public class void main()&#123;&#125;class Inner&#123;&#125; 异常机制（Exception）异常简述 异常指程序运行中出现的不期而至的各种状况，如：文件找不到，网络连接失败，非法参考等 异常发生在程序运行期间，它影响了正常的程序执行流程 异常分类： 检查性异常 运行时异常 错误ERROR 异常处理机制 五个关键字：try, catch, finally, throws 捕获异常 123456789101112131415161718192021//示例try&#123; //try监控区域 //这是一个代码块 &#125;catch(/*要捕获的异常类型*/ArithmeticException ae)&#123; //此处ae应该是生成的异常对象名 //捕获异常 //可以有多个catch，异常类型应由小到大，最终只生效一个，建议最后加一个大异常来见少遗漏 //若出现对应异常运行此处 &#125;catch(/*要捕获的异常类型*/NullPointerException ne)&#123; ...&#125;finally&#123; //处理善后 //可以取舍，但建议用来释放资源 //无论是否异常都运行此处 &#125; 选中 CTRL + ALT + T 有了try catch等异常处理后可以避免程序卡死 抛出异常 123public void test()throws ArithmeticException&#123;//抛到上一级，让调用其的地方捕获 throw new ArithmeticException(); //主动生成异常，一般在方法中使用 &#125; 自定义异常 只需要继承Exception类即可 一些快捷键 ctrl+shift+alt：多行操作psvm：生成main()方法；fori：生成for循环；Ctrl+Alt+v：自动补齐返回值类型ctrl+o：覆写方法ctrl+i：实现接口中的方法ctrl+shift+u：大小写转换CTRL+SHIFT+Z：取消撤销Alt＋Insert：生成构造方法、getter、setterctrl+y：删除当前行Ctrl+Shift+J：将选中的行合并成一行ctrl+g：定位到某一行Ctrl+Shitft+向下箭头：将光标所在的代码块向下整体移动Ctrl+Shift+向上箭头：将光标所在的代码块向上整体移动Alt+Shift+向下箭头：将行向下移动Alt+Shift+向上箭头：将行向上移动Ctrl+F：在当前文件中查找Ctrl+R：替换字符串Ctrl+Shift+F:在全局文件中查找字符串Ctrl+Shift+R：在全局中替换字符串Ctrl+Shift+Enter：自动补齐{}或者分号;Shift+Enter：在当前行的下方开始新行Ctrl+Alt+Enter：在当前行的上方插入新行Ctrl+Delete：删除光标所在至单词结尾处的所有字符 参考教学视频","categories":[],"tags":[{"name":"基础学习","slug":"基础学习","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Markdown语法","slug":"MD基本语法","date":"2020-10-06T16:00:00.000Z","updated":"2020-10-07T15:24:58.838Z","comments":true,"path":"2020/10/07/MD基本语法/","link":"","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/2020/10/07/MD%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Markdown语法1.代码块 “ ```语言 “ 12345678//cpp with hello worldinclude&lt;iostream.h&gt;using namespace std;void main()&#123; cout&lt;&lt;&quot;hello wordl&quot;&lt;&lt;endl;&#125; 12import turtleprint(&quot;hello world&quot;) 2.标题123#[空格] 一级##[空格] 二级###[空格] 三级 3.字体12345678//加粗**无产阶级**//代码高亮显示==资产阶级==//删除线~~阶级斗争~~//斜体*中产阶级* 无产阶级 ==阶级斗争== 资产阶级 中产阶级 4.引用123//引用语法&gt;作者：赵航锐&gt;&gt;作者：赵航锐 作者：*** 作者 作者 5.分割线12345//分割线---//分割线*** 6.图片插入12//在线图片/本地图片![我的图片](路径) 7.超链接12&#x2F;&#x2F;超链接语法[我的码云](https:&#x2F;&#x2F;gitee.com&#x2F;feoar) 我的码云 8.列表1234567//无序列表- 目录1- 目录2- 目录3 //有序列表1.项目2.项目 目录1 目录2 目录3 项目 项目 9.表格Quick Start hello blog Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"基础学习","slug":"基础学习","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Markdown form CSDN","slug":"CSDN_MD_GRAMMAR","date":"2020-10-06T16:00:00.000Z","updated":"2020-10-07T15:30:21.869Z","comments":true,"path":"2020/10/07/CSDN_MD_GRAMMAR/","link":"","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/2020/10/07/CSDN_MD_GRAMMAR/","excerpt":"","text":"@TOC 欢迎使用Markdown编辑器你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。 新的改变我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客： 全新的界面设计 ，将会带来全新的写作体验； 在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示； 增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示； 全新的 KaTeX数学公式 语法； 增加了支持甘特图的mermaid语法^1 功能； 增加了 多屏幕编辑 Markdown文章功能； 增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间； 增加了 检查列表 功能。 功能快捷键撤销：Ctrl/Command + Z重做：Ctrl/Command + Y加粗：Ctrl/Command + B斜体：Ctrl/Command + I标题：Ctrl/Command + Shift + H无序列表：Ctrl/Command + Shift + U有序列表：Ctrl/Command + Shift + O检查列表：Ctrl/Command + Shift + C插入代码：Ctrl/Command + Shift + K插入链接：Ctrl/Command + Shift + L插入图片：Ctrl/Command + Shift + G查找：Ctrl/Command + F替换：Ctrl/Command + G 合理的创建标题，有助于目录的生成直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。 如何改变文本的样式强调文本 强调文本 加粗文本 加粗文本 ==标记文本== 删除文本 引用文本 H2O is是液体。 2^10^ 运算结果是 1024. 插入链接与图片链接: link. 图片: 带尺寸的图片: ![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw =30x30) 居中的图片: 居中并且带尺寸的图片: ![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center =30x30) 当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。 如何插入一段漂亮的代码片去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片. 12// An highlighted blockvar foo = &#x27;bar&#x27;; 生成一个适合你的列表 项目 项目 项目 项目1 项目2 项目3 计划任务 完成任务 创建一个表格一个简单的表格是这么创建的：| 项目 | Value || —- | —– || 电脑 | $1600 || 手机 | $12 || 导管 | $1 | 设定内容居中、居左、居右使用:---------:居中使用:----------居左使用----------:居右| 第一列 | 第二列 | 第三列 || :————: | ————-: | :————- || 第一列文本居中 | 第二列文本居右 | 第三列文本居左 | SmartyPantsSmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：| TYPE |ASCII |HTML|—————-|——————————-|—————————–||Single backticks|&#39;Isn&#39;t this fun?&#39; |’Isn’t this fun?’ ||Quotes |&quot;Isn&#39;t this fun?&quot; |”Isn’t this fun?” ||Dashes |-- is en-dash, --- is em-dash|– is en-dash, — is em-dash| 创建一个自定义列表MarkdownText-to-HTML conversion toolAuthors: JohnLuke如何创建一个注脚一个具有注脚的文本。^2 注释也是必不可少的Markdown将文本转换为 HTML。 *[HTML]: 超文本标记语言 KaTeX数学公式您可以使用渲染LaTeX数学表达式 KaTeX: Gamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\foralln\\in\\mathbb N$ 是通过欧拉积分 $$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt,.$$ 你可以找到更多关于的信息 LaTeX 数学表达式here. 新的甘特图功能，丰富你的文章12345678gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section 现有任务 已完成 :done, des1, 2014-01-06,2014-01-08 进行中 :active, des2, 2014-01-09, 3d 计划一 : des3, after des2, 5d 计划二 : des4, after des3, 5d 关于 甘特图 语法，参考 这儿, UML 图表可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图： 123456789sequenceDiagram张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?李四--&gt;&gt;王五: 你最近怎么样，王五？李四--x 张三: 我很好，谢谢!李四-x 王五: 我很好，谢谢!Note right of 王五: 李四想了很长时间, 文字太长了&lt;br&#x2F;&gt;不适合放在一行.李四--&gt;&gt;张三: 打量着王五...张三-&gt;&gt;王五: 很好... 王五, 你怎么样? 这将产生一个流程图。: 12345graph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D 关于 Mermaid 语法，参考 这儿, FLowchart流程图我们依旧会支持flowchart的流程图： 123456789flowchatst&#x3D;&gt;start: 开始e&#x3D;&gt;end: 结束op&#x3D;&gt;operation: 我的操作cond&#x3D;&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 关于 Flowchart流程图 语法，参考 这儿. 导出与导入导出如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 文章导出 ，生成一个.md文件或者.html文件进行本地保存。 导入如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，继续你的创作。","categories":[],"tags":[{"name":"引用备忘","slug":"引用备忘","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E5%BC%95%E7%94%A8%E5%A4%87%E5%BF%98/"}]},{"title":"汇编语言","slug":"汇编语言","date":"2020-10-06T16:00:00.000Z","updated":"2020-10-08T12:46:40.043Z","comments":true,"path":"2020/10/07/汇编语言/","link":"","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/2020/10/07/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/","excerpt":"","text":"汇编语言1. CPU,寄存器，内存 CPU由运算器，控制器，寄存器构成 CPU引出了三种总线：地址总线，控制总线，数据总线 地址总线的宽度决定了CPU的寻址能力 数据总线的宽度决定了CPU与其他旗舰进行数据传送时一次传输的数据量 控制总线的宽度决定了CPU对系统中其他器件的控制能力 8086寄存器 8086寄存器为16位 运算器一次运算16位数据 寄存器最大宽度16位 寄存器与运算器之间的通路16位 8086有14个寄存器：AX, BX, CX, DX, SI, DI, SP, BP, IP, CS, SS, DS, ES, PSW 段寄存器：CS, SS, DS, ES 偏移地址寄存器：IP 通用寄存器为：AX, BX, CX, DX ，可以拆分位高低八位寄存器比如：AH与AL 2.汇编指令（核心） 机器码的助记符，有对应的机器码 MOV指令 eg. ​ mov ax,18 || 将18送入寄存器AX（18位立即数） ​ mov ah,78 ​ mov ax, bx || 将bx中的值移入ax || 原理是将bx中的内容复制到ax ADD指令 eg. ​ add ax,78 || ax中的值加78 ​ add ax, bx || ax和bx中的数值相加，结果存在ax中 溢出丢弃最高位，低位寄存器独立看待同样丢弃最高位 指令的操作对象位数相同 3.伪指令 没有对应的机器码，由编译器执行，计算机并不执行 4.其他符号 如+, -, *, /, 等，由编译器识别，没有对应机器码。 5.其他物理地址 段地址（16位）*16 + 偏移地址（16位）= 物理地址（20位） 20位物理地址意味着寻址能力达到2^20即1MB 以上相加过程在地址加法器中实现，然后物理地址送到I/O电路，再到地址总线到内存","categories":[],"tags":[{"name":"基础学习","slug":"基础学习","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"读书笔记","slug":"读书笔记","date":"2020-10-06T16:00:00.000Z","updated":"2020-10-07T15:28:55.057Z","comments":true,"path":"2020/10/07/读书笔记/","link":"","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/2020/10/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","excerpt":"","text":"读书笔记《毛泽东文选》谁是我们的敌人?谁是我们的朋友?这个问题是革命的首要问题。中国过去一切革命斗争成效甚少，其基本原因就是因为不能团结真正的朋友，以攻击真正的敌人。革命党是群众的向导，在革命中未有革命党领错了路而革命不失败的。我们的革命要有不领错路和一定成功的把握，不可不注意团结我们的真正的朋友，以攻击我们的真正的敌人。我们要分辨真正的敌友，不可不将中国社会各阶级的经济地位及其对于革命的态度，作一个大概的分析。 开篇点明了革命的关键问题，我们的敌人是谁，要革谁的命，谁将是我们的同志，谁又是潜在的敌人，谁又是潜在的队友；都需要搞明白弄清楚才能有以此为基础之一的战略制定。我想起了孟子的一篇文章中的话“得道者多助，失道者寡助。寡助之至，亲戚畔之。多助之至，天下顺之。以天下之所顺，攻亲戚之所畔，故君子有不战，战必胜矣。 ”， 意思是能行“仁政”的君王，帮助支持他的人就多，不施行“仁政”的君主，支持帮助他的人就少。支持帮助他的人少到了极点，连内外亲属也会背叛他；支持帮助他的人多到了极点，天下所有人都会归顺他。凭着天下人都归顺他的条件，去攻打那连亲属都反对背叛的君王，君子要么不战斗，（如果）战斗就一定会取得胜利。 ​ 地主阶级和买办阶级。在经济落后的半殖民地的中国，地主阶级和买办阶级完全是国际资产阶级的附庸，其生存和发展，是附属于帝国主义的。 中产阶级。这个阶级代表中国城乡资本主义的生产关系。 小资产阶级。如自耕农，手工业主，小知识阶层——学生界、中小学教员、小员司、小事务员、小律师，小商人等都属于这一类。 半无产阶级。此处所谓半无产阶级，包含：绝大部分半自耕农，贫农，小手工业者，店员，小贩等五种。 无产阶级。现代工业无产阶级约二百万人。所谓农村无产阶级，是指长工、月工、零工等雇农而言。 此外，还有数量不小的游民无产者，为失了土地的农民和失了工作机会的手工业工人。 综上所述，可知一切勾结帝国主义的军阀、官僚、买办阶级、大地主阶级以及附属于他们的一部分反动知识界，是我们的敌人。工业无产阶级是我们革命的领导力量。一切半无产阶级、小资产阶级，是我们最接近的朋友。那动摇不定的中产阶级，其右翼可能是我们的敌人，其左翼可能是我们的朋友——但我们要时常提防他们，不要让他们扰乱了我们的阵线。 这几段我有所删减，几段文字精准的抛析了当代中国社会的人员阶级结构以及比重。结合第一段，找到了革命的主力军为日后的胜利找到了同盟军。在《江泽民在庆祝建档八十周年大会上的讲话》同样也指明了中国特色社会主义事业的建设者问题，不同历史阶段的两个创造性解答，体现了我们党从现实国情，，党情和外面的世情触发，在马克思主义立场，观点，方法指导下解放思想，实事求是，团结社会各阶层，巩固自己的社会基础，扩大自己的群基础，不断提高党的社会影响力，带领革命斗争多的胜利，带领中国特色社会主义建设取得胜利的远见卓识。为并且随着时代发展，依然适用于现代社会的阶级人员构成。 一国之内，在四围白色政权的包围中，有一小块或若干小块红色政权的区域长期地存在，这是世界各国从来没有的事。这种奇事的发生，有其独特的原因。而其存在和发展，亦必有相当的条件。第一，它的发生不能在任何帝国主义的国家，也不能在任何帝国主义直接统治的殖民地[7]，必然是在帝国主义间接统治的经济落后的半殖民地的中国。因为这种奇怪现象必定伴着另外一件奇怪现象，那就是白色政权之间的战争。帝国主义和国内买办豪绅阶级支持着的各派新旧军阀，从民国元年以来，相互间进行着继续不断的战争，这是半殖民地中国的特征之一。不但全世界帝国主义国家没有一国有这种现象，就是帝国主义直接统治的殖民地也没有一处有这种现象，仅仅帝国主义间接统治的中国这样的国家才有这种现象。这种现象产生的原因有两种，即地方的农业经济(不是统一的资本主义经济)和帝国主义划分势力范围的分裂剥削政策。因为有了白色政权间的长期的分裂和战争，便给了一种条件，使一小块或若干小块的共产党领导的红色区域，能够在四围白色政权包围的中间发生和坚持下来。湘赣边界的割据，就是这许多小块中间的一小块。有些同志在困难和危急的时候，往往怀疑这样的红色政权的存在，而发生悲观的情绪。这是没有找出这种红色政权所以发生和存在的正确的解释的缘故。我们只须知道中国白色政权的分裂和战争是继续不断的，则红色政权的发生、存在并且日益发展，便是无疑的了。第二，中国红色政权首先发生和能够长期地存在的地方，不是那种并未经过民主革命影响的地方，例如四川、贵州、云南及北方各省，而是在一九二六和一九二七两年资产阶级民主革命过程中工农兵士群众曾经大大地起来过的地方，例如湖南、广东、湖北、江西等省。这些省份的许多地方，曾经有过很广大的工会和农民协会的组织，有过工农阶级对地主豪绅阶级和资产阶级的许多经济的政治的斗争。所以广州产生过三天的城市民众政权，而海陆丰、湘东、湘南、湘赣边界、湖北的黄安等地都有过农民的割据[8]。至于此刻的红军，也是由经过民主的政治训练和接受过工农群众影响的国民革命军中分化出来的。那些毫未经过民主的政治训练、毫未接受过工农影响的军队，例如阎锡山、张作霖的军队，此时便决然不能分化出可以造成红军的成分来。第三，小地方民众政权之能否长期地存在，则决定于全国革命形势是否向前发展这一个条件。全国革命形势是向前发展的，则小块红色区域的长期存在，不但没有疑义，而且必然地要作为取得全国政权的许多力量中间的一个力量。全国革命形势若不是继续地向前发展，而有一个比较长期的停顿，则小块红色区域的长期存在是不可能的。现在中国革命形势是跟着国内买办豪绅阶级和国际资产阶级的继续的分裂和战争，而继续地向前发展的。所以，不但小块红色区域的长期存在没有疑义，而且这些红色区域将继续发展，日渐接近于全国政权的取得。第四，相当力量的正式红军的存在，是红色政权存在的必要条件。若只有地方性质的赤卫队[9]而没有正式的红军，则只能对付挨户团[10]，而不能对付正式的白色军队。所以虽有很好的工农群众，若没有相当力量的正式武装，便决然不能造成割据局面，更不能造成长期的和日益发展的割据局面。所以“工农武装割据”的思想，是共产党和割据地方的工农群众必须充分具备的一个重要的思想。第五，红色政权的长期的存在并且发展，除了上述条件之外，还须有一个要紧的条件，就是共产党组织的有力量和它的政策的不错误。 毛泽东写这篇文章时正值第二次革命战争时期，由毛泽东同志所领导的秋收起义和周恩来、朱德等同志所领导的“八．一”南昌起义两支队伍会师井冈山，建立了我党领导的第一个革命根据地。从此，在半封建半殖民地的旧中国的土地上有了属于人民自己的红色政权。它的诞生，使祖祖辈辈受剥削、受压迫的劳动人民看到了希望，看到了曙光，因为共产党所领导的红色政权是人民自己的政权，是为广大劳苦大众谋利益的。在此之前，由于以陈独秀为代表的右倾机会主义者，在第一次国共合作时，没有坚决执行无产阶级自己的领导权，一贯向以蒋介石为代表的国民党右派势力妥协，结果被大地主、大资产阶级篡夺了领导权，以反革命代替了革命。正如毛泽东同志在文章中所提到的“中国迫切需要一个资产阶级的民主革命，这个革命必须由无产阶级领导才能完成。事实也正是这样，1927年蒋介石悍然发动的“四．一二”反革命政变就是如此，血的教训告诉我们，中国共产党如果不掌握自己的革命武装，建立属于自己的红色政权，就不能取得革命的最后胜利 本本主义的社会科学研究法也同样是最危险的，甚至可能走上反革命的道路，中国有许多专门从书本上讨生活的从事社会科学研究的共产党员，不是一批一批地成了反革命吗?就是明显的证据。我们说马克思主义是对的，决不是因为马克思这个人是什么“先哲”，而是因为他的理论，在我们的实践中，在我们的斗争中，证明了是对的。我们的斗争需要马克思主义。我们欢迎这个理论，丝毫不存什么“先哲”一类的形式的甚至神秘的念头在里面。读过马克思主义“本本”的许多人，成了革命叛徒，那些不识字的工人常常能够很好地掌握马克思主义。马克思主义的“本本”是要学习的，但是必须同我国的实际情况相结合。我们需要“本本”，但是一定要纠正脱离实际情况的本本主义。 本本主义即教条主义, 该文从认识论的高度阐明调查研究的重要性，提出了传之后世的“没有调查,就没有发言权”、“中国革命斗争的胜利要靠中国同志了解中国情况”等著名论断，是对马克思主义认识论和历史唯物主义的丰富和发展，蕴含着实事求是、群众路线、独立自主的基本思想，是中国共产党思想路线的雏形。明确表达了实事求是、群众路线、独立自主的基本观点，阐明了中国的马克思主义者对待马克思主义的态度。毛泽东在《反对本本主义》中倡导的实事求是、群众路线、独立自主的精神，对于今日中国落实“四个全面”仍具有重要理论意义与实践价值。 邓小平文选帝国主义的各种花样直到封锁，其目的在于迫我就范，我们的斗争也在于迫使帝国主义就范。我们绝不会就帝国主义之范，而一个多月的经验看出，帝国主义就我之范亦非易事。这一时期双方斗争实际上都是试探的性质，直到英美摊出封锁的牌。封锁，在目前说来，虽增加我们不少困难，但对我仍属有利，即使不封锁，我们许多困难也是不能解决的。但封锁太久了，对我则是极不利的。打破封锁之道，毛主席强调从军事上迅速占领两广云贵川康青宁诸省，尽量求得早日占领沿海各岛及台湾。同时我们提出的外交政策的一面倒，愈早表现于行动则对我愈有利（毛主席说，这样是主动的倒，免得将来被动的倒）；内部政策强调认真的从自力更生打算，不但叫，而且认真着手做（毛主席说，更主要的从长远的新民主主义建设着眼来提出这个问题），毛主席说这两条很好，与中央精神一致。我们这样做，即占领全国、一面倒和自力更生，不但可以立于坚固的基础之上，而且才有可能迫使帝国主义就我之范。 在当前疫情与美帝国主义为首的西方老牌资本主义国家对中国的围追堵截，技术封锁，贸易壁垒的大背景下，邓小平指出了我们绝不投降的方针，清晰的分析的当时的国际形式对国内的影响恰如今日，今天面对技术的封锁与列强的欺压。我国保持着比较强硬的外交政策。经济全球化的今天，国内有不少量的技术依赖于外国，这次收到技术封锁我们只能自力更生，没有就从零开始追赶。美国政府的欺压只会激发中国人的斗志，相信在未来，外国发达资本主义国家对于中国的技术优势只会越来越少甚至被反超。中国的国际地位将会极大的提升，同时配合中国提出的一系列贸易政策以中国为中心的三级贸易圈将会逐渐成熟，国内的低端产业将会如现在一样逐渐向发展中国家迁移，国内的产业将会进一步升级到高端产业。届时，中国将会收割以中国为中心的三级贸易圈的财富，国民的生活水平会逐步提高，这是建立在国内财富分配进一步优化的前提下的。如果如今天一样继续内卷下去，即使可以收割世界的财富，国内中产阶级无产阶级的生活质量有可能继续下降。 习近平讲话系列改革开放以来，我们党始终高度重视正确处理改革发展稳定关系，始终把维护国家安全和社会安定作为党和国家的一项基础性工作。我们保持了我国社会大局稳定，为改革开放和社会主义现代化建设营造了良好环境。“安而不忘危，存而不忘亡，治而不忘乱。”同时，必须清醒地看到，新形势下我国国家安全和社会安定面临的威胁和挑战增多，特别是各种威胁和挑战联动效应明显。我们必须保持清醒头脑、强化底线思维，有效防范、管理、处理国家安全风险，有力应对、处置、化解社会安定挑战。 要加强新形势下反分裂斗争，高举各民族大团结的旗帜，坚持各民族共同团结奋斗、共同繁荣发展的主题，深入开展民族团结宣传教育，打牢民族团结的思想基础，最大限度团结各族群众。要加强基层组织和基层政权建设，多做深入细致的群众工作。要正确把握党的民族、宗教政策，及时妥善解决影响民族团结的矛盾纠纷，坚决遏制和打击境内外敌对势力利用民族问题进行的分裂、渗透、破坏活动。 国家安全是国家生存和发展最基本最重要的前提。自2014年香港“非法占中”以来，港独思潮频频在香港社会抬头。一些分离分子企图通过对民族自决的歪曲，以全民公投的形式谋求“香港独立”；也常有独派借言论自由的名义大肆宣传港独思潮。港独思潮作为一种极端本土主义，若任其自由发展而不采取任何有效措施，必然给香港和内地社会繁荣与稳定带来不可忽略的破坏。在其嚣张的气焰背后不难发现有境外反华势力的支持。这只是众多案例之一，显而易见我国国家安全和社会安定面临的威胁和挑战增多，习主席的讲话对于国家安全问题做了新的概括，顺应时代发展的潮流，回应了广大人民的关切，有十分重要的指导意义。 维护国家安全，必须做好维护社会和谐稳定工作，做好预防化解社会矛盾工作，从制度、机制、政策、工作上积极推动社会矛盾预防化解工作。要增强发展的全面性、协调性、可持续性，加强保障和改善民生工作，从源头上预防和减少社会矛盾的产生。要以促进社会公平正义、增进人民福祉为出发点和落脚点，加大协调各方面利益关系的力度，推动发展成果更多更公平惠及全体人民。要完善和落实维护群众合法权益的体制机制，完善和落实社会稳定风险评估机制，预防和减少利益冲突。要全面推进依法治国，更好维护人民群众合法权益。对各类社会矛盾，要引导群众通过法律程序、运用法律手段解决，推动形成办事依法、遇事找法、解决问题用法、化解矛盾靠法的良好环境。 看到社会层面的指导方针我感慨万千，中国特色社会主义的道路还是很漫长和曲折的。必须要有党的正确的具有前瞻性和胆魄的指导以及人民群众的努力建设才能走下去。 我们党作为百年大党，如何永葆先进性和纯洁性、永葆青春活力，如何永远得到人民拥护和支持，如何实现长期执政，是我们必须回答好、解决好的一个根本性问题。我们党要求全党同志不忘初心、牢记使命，就是要提醒全党同志，党的初心和使命是党的性质宗旨、理想信念、奋斗目标的集中体现，越是长期执政，越不能丢掉马克思主义政党的本色，越不能忘记党的初心使命，越不能丧失自我革命精神。 我们党的初心和使命是建立在马克思主义科学理论基础之上的。马克思、恩格斯在《共产党宣言》中庄严宣告：“过去的一切运动都是少数人的，或者为少数人谋利益的运动。无产阶级的运动是绝大多数人的，为绝大多数人谋利益的独立的运动。”我们党是用马克思主义武装起来的政党，始终把为中国人民谋幸福、为中华民族谋复兴作为自己的初心和使命，并一以贯之体现到党的全部奋斗之中。忘记这个初心和使命，党就会改变性质、改变颜色，就会失去人民、失去未来。只要我们党牢牢坚持立党为公、执政为民，牢牢坚持为中国人民谋幸福、为中华民族谋复兴，不断检视自己，不掩饰缺点，不文过饰非，坚决同一切弱化党的先进性和纯洁性、危害党的肌体健康的现象作斗争，就一定能够始终立于不败之地。 有这样能自省的，始终为人民着想，为人民谋幸福，坚定维护主权，国家利益和人民利益的政党领导，我觉得中国人民是十分幸福的，放眼全世界，有几个国家的政府是这样的呢？这就是人民当家作主，这就是社会主义的优越性之一吧，没有西方资本主义国家的功利，是有人情味的政党。希望我们党能坚守初心，不被资本腐蚀，能继续努力为人民谋幸福，建设更美好的国家。","categories":[],"tags":[{"name":"课后作业","slug":"课后作业","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"}]}],"categories":[],"tags":[{"name":"课后作业","slug":"课后作业","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"},{"name":"基础学习","slug":"基础学习","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"name":"引用备忘","slug":"引用备忘","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E5%BC%95%E7%94%A8%E5%A4%87%E5%BF%98/"}]}